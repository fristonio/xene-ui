// tslint:disable
/**
 * Xene API server
 * Xene is the workflow creator and manager tool
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: deepeshpathak09@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 *
 * @export
 * @interface ResponseAgentInfo
 */
export interface ResponseAgentInfo {
  /**
   *
   * @type {string}
   * @memberof ResponseAgentInfo
   */
  address?: string;
  /**
   *
   * @type {boolean}
   * @memberof ResponseAgentInfo
   */
  available?: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponseAgentInfo
   */
  name?: string;
  /**
   *
   * @type {boolean}
   * @memberof ResponseAgentInfo
   */
  secure?: boolean;
}
/**
 *
 * @export
 * @interface ResponseHTTPError
 */
export interface ResponseHTTPError {
  /**
   *
   * @type {string}
   * @memberof ResponseHTTPError
   */
  error?: string;
}
/**
 *
 * @export
 * @interface ResponseHTTPMessage
 */
export interface ResponseHTTPMessage {
  /**
   *
   * @type {string}
   * @memberof ResponseHTTPMessage
   */
  message?: string;
}
/**
 *
 * @export
 * @interface ResponseJWTAuth
 */
export interface ResponseJWTAuth {
  /**
   *
   * @type {string}
   * @memberof ResponseJWTAuth
   */
  expiresIn?: string;
  /**
   *
   * @type {string}
   * @memberof ResponseJWTAuth
   */
  token?: string;
  /**
   *
   * @type {string}
   * @memberof ResponseJWTAuth
   */
  userEmail?: string;
  /**
   *
   * @type {string}
   * @memberof ResponseJWTAuth
   */
  userName?: string;
}
/**
 *
 * @export
 * @interface ResponseOauthLogin
 */
export interface ResponseOauthLogin {
  /**
   * LoginURL is the URL to be used for logging in.
   * @type {string}
   * @memberof ResponseOauthLogin
   */
  loginURL?: string;
}
/**
 *
 * @export
 * @interface ResponseRegistryItem
 */
export interface ResponseRegistryItem {
  /**
   * Items contains the Serialized kvstore item
   * @type {string}
   * @memberof ResponseRegistryItem
   */
  item?: string;
}
/**
 *
 * @export
 * @interface ResponseRegistryItemsFromPrefix
 */
export interface ResponseRegistryItemsFromPrefix {
  /**
   *
   * @type {number}
   * @memberof ResponseRegistryItemsFromPrefix
   */
  count?: number;
  /**
   * Items contains the Serialized kvstore items
   * @type {Array<string>}
   * @memberof ResponseRegistryItemsFromPrefix
   */
  items?: Array<string>;
}
/**
 *
 * @export
 * @interface ResponseSecretInfo
 */
export interface ResponseSecretInfo {
  /**
   *
   * @type {string}
   * @memberof ResponseSecretInfo
   */
  name?: string;
  /**
   *
   * @type {boolean}
   * @memberof ResponseSecretInfo
   */
  restricted?: boolean;
  /**
   *
   * @type {string}
   * @memberof ResponseSecretInfo
   */
  type?: string;
}
/**
 *
 * @export
 * @interface ResponseWorkflowInfo
 */
export interface ResponseWorkflowInfo {
  /**
   *
   * @type {Array<string>}
   * @memberof ResponseWorkflowInfo
   */
  agents?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ResponseWorkflowInfo
   */
  name?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ResponseWorkflowInfo
   */
  pipelines?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ResponseWorkflowInfo
   */
  triggers?: Array<string>;
}

/**
 * ApiApi - axios parameter creator
 * @export
 */
export const ApiApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * auth OK handler handles the ping to api routes which are
     * @summary Handles ping event for api routes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1AuthokGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/authok`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function (configuration?: Configuration) {
  return {
    /**
     * auth OK handler handles the ping to api routes which are
     * @summary Handles ping event for api routes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1AuthokGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseHTTPMessage>
    > {
      const localVarAxiosArgs = await ApiApiAxiosParamCreator(
        configuration
      ).apiV1AuthokGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * auth OK handler handles the ping to api routes which are
     * @summary Handles ping event for api routes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1AuthokGet(options?: any): AxiosPromise<ResponseHTTPMessage> {
      return ApiApiFp(configuration)
        .apiV1AuthokGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
  /**
   * auth OK handler handles the ping to api routes which are
   * @summary Handles ping event for api routes.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiApi
   */
  public apiV1AuthokGet(options?: any) {
    return ApiApiFp(this.configuration)
      .apiV1AuthokGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Log in to xene using the configured oauth providers that xene supports.
     * @summary Handles login for xene
     * @param {string} provider Provider for oauth login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthProviderGet: async (
      provider: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'provider' is not null or undefined
      if (provider === null || provider === undefined) {
        throw new RequiredError(
          "provider",
          "Required parameter provider was null or undefined when calling oauthProviderGet."
        );
      }
      const localVarPath = `/oauth/:provider`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (provider !== undefined) {
        localVarQueryParameter["provider"] = provider;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * redirectHandler handles the redirect from the Oauth provider after the authentication process has
     * @summary Handles redirect from the login oauth provider.
     * @param {string} provider Provider for the oauth redirect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthProviderRedirectGet: async (
      provider: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'provider' is not null or undefined
      if (provider === null || provider === undefined) {
        throw new RequiredError(
          "provider",
          "Required parameter provider was null or undefined when calling oauthProviderRedirectGet."
        );
      }
      const localVarPath = `/oauth/:provider/redirect`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (provider !== undefined) {
        localVarQueryParameter["provider"] = provider;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles authentication token refresh
     * @summary Handle authentication token refresh for the oauth provider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthRefreshGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/oauth/refresh/`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Log in to xene using the configured oauth providers that xene supports.
     * @summary Handles login for xene
     * @param {string} provider Provider for oauth login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oauthProviderGet(
      provider: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseOauthLogin>
    > {
      const localVarAxiosArgs = await AuthApiAxiosParamCreator(
        configuration
      ).oauthProviderGet(provider, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * redirectHandler handles the redirect from the Oauth provider after the authentication process has
     * @summary Handles redirect from the login oauth provider.
     * @param {string} provider Provider for the oauth redirect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oauthProviderRedirectGet(
      provider: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseJWTAuth>
    > {
      const localVarAxiosArgs = await AuthApiAxiosParamCreator(
        configuration
      ).oauthProviderRedirectGet(provider, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Handles authentication token refresh
     * @summary Handle authentication token refresh for the oauth provider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oauthRefreshGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseJWTAuth>
    > {
      const localVarAxiosArgs = await AuthApiAxiosParamCreator(
        configuration
      ).oauthRefreshGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Log in to xene using the configured oauth providers that xene supports.
     * @summary Handles login for xene
     * @param {string} provider Provider for oauth login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthProviderGet(
      provider: string,
      options?: any
    ): AxiosPromise<ResponseOauthLogin> {
      return AuthApiFp(configuration)
        .oauthProviderGet(provider, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * redirectHandler handles the redirect from the Oauth provider after the authentication process has
     * @summary Handles redirect from the login oauth provider.
     * @param {string} provider Provider for the oauth redirect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthProviderRedirectGet(
      provider: string,
      options?: any
    ): AxiosPromise<ResponseJWTAuth> {
      return AuthApiFp(configuration)
        .oauthProviderRedirectGet(provider, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles authentication token refresh
     * @summary Handle authentication token refresh for the oauth provider.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthRefreshGet(options?: any): AxiosPromise<ResponseJWTAuth> {
      return AuthApiFp(configuration)
        .oauthRefreshGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   * Log in to xene using the configured oauth providers that xene supports.
   * @summary Handles login for xene
   * @param {string} provider Provider for oauth login
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public oauthProviderGet(provider: string, options?: any) {
    return AuthApiFp(this.configuration)
      .oauthProviderGet(provider, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * redirectHandler handles the redirect from the Oauth provider after the authentication process has
   * @summary Handles redirect from the login oauth provider.
   * @param {string} provider Provider for the oauth redirect
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public oauthProviderRedirectGet(provider: string, options?: any) {
    return AuthApiFp(this.configuration)
      .oauthProviderRedirectGet(provider, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles authentication token refresh
   * @summary Handle authentication token refresh for the oauth provider.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public oauthRefreshGet(options?: any) {
    return AuthApiFp(this.configuration)
      .oauthRefreshGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns the health status of the API server.
     * @summary Health route for Xene API server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/health`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns the health status of the API server.
     * @summary Health route for Xene API server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async healthGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseHTTPMessage>
    > {
      const localVarAxiosArgs = await HealthApiAxiosParamCreator(
        configuration
      ).healthGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Returns the health status of the API server.
     * @summary Health route for Xene API server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthGet(options?: any): AxiosPromise<ResponseHTTPMessage> {
      return HealthApiFp(configuration)
        .healthGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   * Returns the health status of the API server.
   * @summary Health route for Xene API server.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public healthGet(options?: any) {
    return HealthApiFp(this.configuration)
      .healthGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RegistryApi - axios parameter creator
 * @export
 */
export const RegistryApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * If a name is provided return the corresponding agent object, if prefix is set to some value
     * @summary Returns the specified agent object from the store.
     * @param {string} [prefix] Prefix based get for agent.
     * @param {string} [name] name of the agent to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryAgentGet: async (
      prefix?: string,
      name?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/registry/agent`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      if (prefix !== undefined) {
        localVarQueryParameter["prefix"] = prefix;
      }

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes the agent specified by the name parameter, if the agent is not
     * @summary Deletes the specified agent from the store.
     * @param {string} name Name of the agent to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryAgentNameDelete: async (
      name: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling apiV1RegistryAgentNameDelete."
        );
      }
      const localVarPath = `/api/v1/registry/agent/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns the specified agent object from the store with the name in params.
     * @param {string} name name of the agent to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryAgentNameGet: async (
      name: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling apiV1RegistryAgentNameGet."
        );
      }
      const localVarPath = `/api/v1/registry/agent/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Patches the specified agent from the store.
     * @param {string} name Name of the agent to be patched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryAgentNamePatch: async (
      name: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling apiV1RegistryAgentNamePatch."
        );
      }
      const localVarPath = `/api/v1/registry/agent/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates a new agent in the store.
     * @param {string} agent Agent manifest to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryAgentPost: async (
      agent: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'agent' is not null or undefined
      if (agent === null || agent === undefined) {
        throw new RequiredError(
          "agent",
          "Required parameter agent was null or undefined when calling apiV1RegistryAgentPost."
        );
      }
      const localVarPath = `/api/v1/registry/agent`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      if (agent !== undefined) {
        localVarFormParams.set("agent", agent as any);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/x-www-form-urlencoded";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List all the keys of items in the registry of the provided type agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryListAgentsGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/registry/list/agents`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List all the keys of items in the registry of the provided type agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryListSecretsGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/registry/list/secrets`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gather information about all the workflow objects managed by xene.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryListWorkflowsGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/registry/list/workflows`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * If a name is provided return the corresponding secret object, if prefix is set to some value
     * @summary Returns the specified secret object from the store.
     * @param {string} [prefix] Prefix based get for secret.
     * @param {string} [name] name of the secret to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistrySecretGet: async (
      prefix?: string,
      name?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/registry/secret`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      if (prefix !== undefined) {
        localVarQueryParameter["prefix"] = prefix;
      }

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes the secret specified by the name parameter, if the secret is not
     * @summary Deletes the specified secret from the store.
     * @param {string} name Name of the secret to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistrySecretNameDelete: async (
      name: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling apiV1RegistrySecretNameDelete."
        );
      }
      const localVarPath = `/api/v1/registry/secret/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns the specified secret object from the store with the name in params.
     * @param {string} name name of the secret to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistrySecretNameGet: async (
      name: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling apiV1RegistrySecretNameGet."
        );
      }
      const localVarPath = `/api/v1/registry/secret/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Patches the specified secret from the store.
     * @param {string} name Name of the secret to be patched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistrySecretNamePatch: async (
      name: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling apiV1RegistrySecretNamePatch."
        );
      }
      const localVarPath = `/api/v1/registry/secret/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates a new secret in the store.
     * @param {string} secret secret manifest to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistrySecretPost: async (
      secret: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'secret' is not null or undefined
      if (secret === null || secret === undefined) {
        throw new RequiredError(
          "secret",
          "Required parameter secret was null or undefined when calling apiV1RegistrySecretPost."
        );
      }
      const localVarPath = `/api/v1/registry/secret`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      if (secret !== undefined) {
        localVarFormParams.set("secret", secret as any);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/x-www-form-urlencoded";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * If a name is provided return the corresponding workflow object, if prefix  is set to some value
     * @summary Returns the specified workflow object from the store.
     * @param {string} [prefix] Prefix based get for workflow.
     * @param {string} [name] name of the workflow to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryWorkflowGet: async (
      prefix?: string,
      name?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/registry/workflow`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      if (prefix !== undefined) {
        localVarQueryParameter["prefix"] = prefix;
      }

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes the workflow specified by the name parameter, if the workflow is not
     * @summary Deletes the specified workflow from the store.
     * @param {string} name Name of the workflow to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryWorkflowNameDelete: async (
      name: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling apiV1RegistryWorkflowNameDelete."
        );
      }
      const localVarPath = `/api/v1/registry/workflow/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns the specified workflow object from the store with the name in params.
     * @param {string} name name of the workflow to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryWorkflowNameGet: async (
      name: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling apiV1RegistryWorkflowNameGet."
        );
      }
      const localVarPath = `/api/v1/registry/workflow/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Patches the specified workflow from the store.
     * @param {string} name Name of the workflow to be patched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryWorkflowNamePatch: async (
      name: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling apiV1RegistryWorkflowNamePatch."
        );
      }
      const localVarPath = `/api/v1/registry/workflow/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This route creates a new workflow for xene to operate on, if the workflow already exists
     * @summary Creates a new workflow in the store.
     * @param {string} workflow Workflow manifest to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryWorkflowPost: async (
      workflow: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'workflow' is not null or undefined
      if (workflow === null || workflow === undefined) {
        throw new RequiredError(
          "workflow",
          "Required parameter workflow was null or undefined when calling apiV1RegistryWorkflowPost."
        );
      }
      const localVarPath = `/api/v1/registry/workflow`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      if (workflow !== undefined) {
        localVarFormParams.set("workflow", workflow as any);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/x-www-form-urlencoded";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Patches the specified workflow status from the store.
     * @param {string} name Name of the workflow status to be patched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1StatusWorkflowNamePatch: async (
      name: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling apiV1StatusWorkflowNamePatch."
        );
      }
      const localVarPath = `/api/v1/status/workflow/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RegistryApi - functional programming interface
 * @export
 */
export const RegistryApiFp = function (configuration?: Configuration) {
  return {
    /**
     * If a name is provided return the corresponding agent object, if prefix is set to some value
     * @summary Returns the specified agent object from the store.
     * @param {string} [prefix] Prefix based get for agent.
     * @param {string} [name] name of the agent to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistryAgentGet(
      prefix?: string,
      name?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseRegistryItem>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistryAgentGet(prefix, name, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Deletes the agent specified by the name parameter, if the agent is not
     * @summary Deletes the specified agent from the store.
     * @param {string} name Name of the agent to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistryAgentNameDelete(
      name: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseHTTPMessage>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistryAgentNameDelete(name, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Returns the specified agent object from the store with the name in params.
     * @param {string} name name of the agent to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistryAgentNameGet(
      name: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseRegistryItem>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistryAgentNameGet(name, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Patches the specified agent from the store.
     * @param {string} name Name of the agent to be patched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistryAgentNamePatch(
      name: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistryAgentNamePatch(name, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Creates a new agent in the store.
     * @param {string} agent Agent manifest to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistryAgentPost(
      agent: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseHTTPMessage>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistryAgentPost(agent, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary List all the keys of items in the registry of the provided type agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistryListAgentsGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ResponseAgentInfo>>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistryListAgentsGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary List all the keys of items in the registry of the provided type agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistryListSecretsGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ResponseSecretInfo>>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistryListSecretsGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Gather information about all the workflow objects managed by xene.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistryListWorkflowsGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ResponseWorkflowInfo>>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistryListWorkflowsGet(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * If a name is provided return the corresponding secret object, if prefix is set to some value
     * @summary Returns the specified secret object from the store.
     * @param {string} [prefix] Prefix based get for secret.
     * @param {string} [name] name of the secret to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistrySecretGet(
      prefix?: string,
      name?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseRegistryItem>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistrySecretGet(prefix, name, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Deletes the secret specified by the name parameter, if the secret is not
     * @summary Deletes the specified secret from the store.
     * @param {string} name Name of the secret to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistrySecretNameDelete(
      name: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseHTTPMessage>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistrySecretNameDelete(name, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Returns the specified secret object from the store with the name in params.
     * @param {string} name name of the secret to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistrySecretNameGet(
      name: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseRegistryItem>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistrySecretNameGet(name, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Patches the specified secret from the store.
     * @param {string} name Name of the secret to be patched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistrySecretNamePatch(
      name: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistrySecretNamePatch(name, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Creates a new secret in the store.
     * @param {string} secret secret manifest to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistrySecretPost(
      secret: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseHTTPMessage>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistrySecretPost(secret, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * If a name is provided return the corresponding workflow object, if prefix  is set to some value
     * @summary Returns the specified workflow object from the store.
     * @param {string} [prefix] Prefix based get for workflow.
     * @param {string} [name] name of the workflow to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistryWorkflowGet(
      prefix?: string,
      name?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseRegistryItem>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistryWorkflowGet(prefix, name, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Deletes the workflow specified by the name parameter, if the workflow is not
     * @summary Deletes the specified workflow from the store.
     * @param {string} name Name of the workflow to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistryWorkflowNameDelete(
      name: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseHTTPMessage>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistryWorkflowNameDelete(name, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Returns the specified workflow object from the store with the name in params.
     * @param {string} name name of the workflow to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistryWorkflowNameGet(
      name: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseRegistryItem>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistryWorkflowNameGet(name, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Patches the specified workflow from the store.
     * @param {string} name Name of the workflow to be patched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistryWorkflowNamePatch(
      name: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistryWorkflowNamePatch(name, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This route creates a new workflow for xene to operate on, if the workflow already exists
     * @summary Creates a new workflow in the store.
     * @param {string} workflow Workflow manifest to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1RegistryWorkflowPost(
      workflow: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseHTTPMessage>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1RegistryWorkflowPost(workflow, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Patches the specified workflow status from the store.
     * @param {string} name Name of the workflow status to be patched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1StatusWorkflowNamePatch(
      name: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RegistryApiAxiosParamCreator(
        configuration
      ).apiV1StatusWorkflowNamePatch(name, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * RegistryApi - factory interface
 * @export
 */
export const RegistryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * If a name is provided return the corresponding agent object, if prefix is set to some value
     * @summary Returns the specified agent object from the store.
     * @param {string} [prefix] Prefix based get for agent.
     * @param {string} [name] name of the agent to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryAgentGet(
      prefix?: string,
      name?: string,
      options?: any
    ): AxiosPromise<ResponseRegistryItem> {
      return RegistryApiFp(configuration)
        .apiV1RegistryAgentGet(prefix, name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes the agent specified by the name parameter, if the agent is not
     * @summary Deletes the specified agent from the store.
     * @param {string} name Name of the agent to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryAgentNameDelete(
      name: string,
      options?: any
    ): AxiosPromise<ResponseHTTPMessage> {
      return RegistryApiFp(configuration)
        .apiV1RegistryAgentNameDelete(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns the specified agent object from the store with the name in params.
     * @param {string} name name of the agent to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryAgentNameGet(
      name: string,
      options?: any
    ): AxiosPromise<ResponseRegistryItem> {
      return RegistryApiFp(configuration)
        .apiV1RegistryAgentNameGet(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Patches the specified agent from the store.
     * @param {string} name Name of the agent to be patched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryAgentNamePatch(
      name: string,
      options?: any
    ): AxiosPromise<void> {
      return RegistryApiFp(configuration)
        .apiV1RegistryAgentNamePatch(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates a new agent in the store.
     * @param {string} agent Agent manifest to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryAgentPost(
      agent: string,
      options?: any
    ): AxiosPromise<ResponseHTTPMessage> {
      return RegistryApiFp(configuration)
        .apiV1RegistryAgentPost(agent, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List all the keys of items in the registry of the provided type agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryListAgentsGet(
      options?: any
    ): AxiosPromise<Array<ResponseAgentInfo>> {
      return RegistryApiFp(configuration)
        .apiV1RegistryListAgentsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List all the keys of items in the registry of the provided type agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryListSecretsGet(
      options?: any
    ): AxiosPromise<Array<ResponseSecretInfo>> {
      return RegistryApiFp(configuration)
        .apiV1RegistryListSecretsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gather information about all the workflow objects managed by xene.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryListWorkflowsGet(
      options?: any
    ): AxiosPromise<Array<ResponseWorkflowInfo>> {
      return RegistryApiFp(configuration)
        .apiV1RegistryListWorkflowsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * If a name is provided return the corresponding secret object, if prefix is set to some value
     * @summary Returns the specified secret object from the store.
     * @param {string} [prefix] Prefix based get for secret.
     * @param {string} [name] name of the secret to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistrySecretGet(
      prefix?: string,
      name?: string,
      options?: any
    ): AxiosPromise<ResponseRegistryItem> {
      return RegistryApiFp(configuration)
        .apiV1RegistrySecretGet(prefix, name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes the secret specified by the name parameter, if the secret is not
     * @summary Deletes the specified secret from the store.
     * @param {string} name Name of the secret to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistrySecretNameDelete(
      name: string,
      options?: any
    ): AxiosPromise<ResponseHTTPMessage> {
      return RegistryApiFp(configuration)
        .apiV1RegistrySecretNameDelete(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns the specified secret object from the store with the name in params.
     * @param {string} name name of the secret to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistrySecretNameGet(
      name: string,
      options?: any
    ): AxiosPromise<ResponseRegistryItem> {
      return RegistryApiFp(configuration)
        .apiV1RegistrySecretNameGet(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Patches the specified secret from the store.
     * @param {string} name Name of the secret to be patched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistrySecretNamePatch(
      name: string,
      options?: any
    ): AxiosPromise<void> {
      return RegistryApiFp(configuration)
        .apiV1RegistrySecretNamePatch(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates a new secret in the store.
     * @param {string} secret secret manifest to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistrySecretPost(
      secret: string,
      options?: any
    ): AxiosPromise<ResponseHTTPMessage> {
      return RegistryApiFp(configuration)
        .apiV1RegistrySecretPost(secret, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * If a name is provided return the corresponding workflow object, if prefix  is set to some value
     * @summary Returns the specified workflow object from the store.
     * @param {string} [prefix] Prefix based get for workflow.
     * @param {string} [name] name of the workflow to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryWorkflowGet(
      prefix?: string,
      name?: string,
      options?: any
    ): AxiosPromise<ResponseRegistryItem> {
      return RegistryApiFp(configuration)
        .apiV1RegistryWorkflowGet(prefix, name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes the workflow specified by the name parameter, if the workflow is not
     * @summary Deletes the specified workflow from the store.
     * @param {string} name Name of the workflow to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryWorkflowNameDelete(
      name: string,
      options?: any
    ): AxiosPromise<ResponseHTTPMessage> {
      return RegistryApiFp(configuration)
        .apiV1RegistryWorkflowNameDelete(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns the specified workflow object from the store with the name in params.
     * @param {string} name name of the workflow to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryWorkflowNameGet(
      name: string,
      options?: any
    ): AxiosPromise<ResponseRegistryItem> {
      return RegistryApiFp(configuration)
        .apiV1RegistryWorkflowNameGet(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Patches the specified workflow from the store.
     * @param {string} name Name of the workflow to be patched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryWorkflowNamePatch(
      name: string,
      options?: any
    ): AxiosPromise<void> {
      return RegistryApiFp(configuration)
        .apiV1RegistryWorkflowNamePatch(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This route creates a new workflow for xene to operate on, if the workflow already exists
     * @summary Creates a new workflow in the store.
     * @param {string} workflow Workflow manifest to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1RegistryWorkflowPost(
      workflow: string,
      options?: any
    ): AxiosPromise<ResponseHTTPMessage> {
      return RegistryApiFp(configuration)
        .apiV1RegistryWorkflowPost(workflow, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Patches the specified workflow status from the store.
     * @param {string} name Name of the workflow status to be patched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1StatusWorkflowNamePatch(
      name: string,
      options?: any
    ): AxiosPromise<void> {
      return RegistryApiFp(configuration)
        .apiV1StatusWorkflowNamePatch(name, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RegistryApi - object-oriented interface
 * @export
 * @class RegistryApi
 * @extends {BaseAPI}
 */
export class RegistryApi extends BaseAPI {
  /**
   * If a name is provided return the corresponding agent object, if prefix is set to some value
   * @summary Returns the specified agent object from the store.
   * @param {string} [prefix] Prefix based get for agent.
   * @param {string} [name] name of the agent to get.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistryAgentGet(prefix?: string, name?: string, options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistryAgentGet(prefix, name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes the agent specified by the name parameter, if the agent is not
   * @summary Deletes the specified agent from the store.
   * @param {string} name Name of the agent to be deleted.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistryAgentNameDelete(name: string, options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistryAgentNameDelete(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns the specified agent object from the store with the name in params.
   * @param {string} name name of the agent to get.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistryAgentNameGet(name: string, options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistryAgentNameGet(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Patches the specified agent from the store.
   * @param {string} name Name of the agent to be patched.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistryAgentNamePatch(name: string, options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistryAgentNamePatch(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates a new agent in the store.
   * @param {string} agent Agent manifest to be created.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistryAgentPost(agent: string, options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistryAgentPost(agent, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List all the keys of items in the registry of the provided type agent.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistryListAgentsGet(options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistryListAgentsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List all the keys of items in the registry of the provided type agent.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistryListSecretsGet(options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistryListSecretsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gather information about all the workflow objects managed by xene.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistryListWorkflowsGet(options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistryListWorkflowsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * If a name is provided return the corresponding secret object, if prefix is set to some value
   * @summary Returns the specified secret object from the store.
   * @param {string} [prefix] Prefix based get for secret.
   * @param {string} [name] name of the secret to get.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistrySecretGet(prefix?: string, name?: string, options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistrySecretGet(prefix, name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes the secret specified by the name parameter, if the secret is not
   * @summary Deletes the specified secret from the store.
   * @param {string} name Name of the secret to be deleted.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistrySecretNameDelete(name: string, options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistrySecretNameDelete(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns the specified secret object from the store with the name in params.
   * @param {string} name name of the secret to get.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistrySecretNameGet(name: string, options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistrySecretNameGet(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Patches the specified secret from the store.
   * @param {string} name Name of the secret to be patched.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistrySecretNamePatch(name: string, options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistrySecretNamePatch(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates a new secret in the store.
   * @param {string} secret secret manifest to be created.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistrySecretPost(secret: string, options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistrySecretPost(secret, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * If a name is provided return the corresponding workflow object, if prefix  is set to some value
   * @summary Returns the specified workflow object from the store.
   * @param {string} [prefix] Prefix based get for workflow.
   * @param {string} [name] name of the workflow to get.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistryWorkflowGet(
    prefix?: string,
    name?: string,
    options?: any
  ) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistryWorkflowGet(prefix, name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes the workflow specified by the name parameter, if the workflow is not
   * @summary Deletes the specified workflow from the store.
   * @param {string} name Name of the workflow to be deleted.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistryWorkflowNameDelete(name: string, options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistryWorkflowNameDelete(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns the specified workflow object from the store with the name in params.
   * @param {string} name name of the workflow to get.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistryWorkflowNameGet(name: string, options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistryWorkflowNameGet(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Patches the specified workflow from the store.
   * @param {string} name Name of the workflow to be patched.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistryWorkflowNamePatch(name: string, options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistryWorkflowNamePatch(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This route creates a new workflow for xene to operate on, if the workflow already exists
   * @summary Creates a new workflow in the store.
   * @param {string} workflow Workflow manifest to be created.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1RegistryWorkflowPost(workflow: string, options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1RegistryWorkflowPost(workflow, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Patches the specified workflow status from the store.
   * @param {string} name Name of the workflow status to be patched.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RegistryApi
   */
  public apiV1StatusWorkflowNamePatch(name: string, options?: any) {
    return RegistryApiFp(this.configuration)
      .apiV1StatusWorkflowNamePatch(name, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Returns the specified workflowStatus object from the store.
     * @param {string} [prefix] Prefix based get for workflow status documents.
     * @param {string} [name] name of the workflow to get status object for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1StatusWorkflowGet: async (
      prefix?: string,
      name?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/status/workflow`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      if (prefix !== undefined) {
        localVarQueryParameter["prefix"] = prefix;
      }

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes the workflow status specified by the name parameter, if the workflow is not
     * @summary Deletes the specified workflow from the store.
     * @param {string} name Name of the workflow status to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1StatusWorkflowNameDelete: async (
      name: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling apiV1StatusWorkflowNameDelete."
        );
      }
      const localVarPath = `/api/v1/status/workflow/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns the specified workflow object from the store with the name in params.
     * @param {string} name name of the workflow to get status document for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1StatusWorkflowNameGet: async (
      name: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling apiV1StatusWorkflowNameGet."
        );
      }
      const localVarPath = `/api/v1/status/workflow/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This route creates a new workflow status for xene to operate on, if the workflow already exists
     * @summary Creates a new workflow status in the store.
     * @param {string} workflow WorkflowStatus manifest to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1StatusWorkflowPost: async (
      workflow: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'workflow' is not null or undefined
      if (workflow === null || workflow === undefined) {
        throw new RequiredError(
          "workflow",
          "Required parameter workflow was null or undefined when calling apiV1StatusWorkflowPost."
        );
      }
      const localVarPath = `/api/v1/status/workflow`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      // authentication ApiKeyAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? await configuration.apiKey("Authorization")
            : await configuration.apiKey;
        localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
      }

      if (workflow !== undefined) {
        localVarFormParams.set("workflow", workflow as any);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/x-www-form-urlencoded";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Returns the specified workflowStatus object from the store.
     * @param {string} [prefix] Prefix based get for workflow status documents.
     * @param {string} [name] name of the workflow to get status object for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1StatusWorkflowGet(
      prefix?: string,
      name?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseRegistryItem>
    > {
      const localVarAxiosArgs = await StatusApiAxiosParamCreator(
        configuration
      ).apiV1StatusWorkflowGet(prefix, name, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Deletes the workflow status specified by the name parameter, if the workflow is not
     * @summary Deletes the specified workflow from the store.
     * @param {string} name Name of the workflow status to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1StatusWorkflowNameDelete(
      name: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseHTTPMessage>
    > {
      const localVarAxiosArgs = await StatusApiAxiosParamCreator(
        configuration
      ).apiV1StatusWorkflowNameDelete(name, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     *
     * @summary Returns the specified workflow object from the store with the name in params.
     * @param {string} name name of the workflow to get status document for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1StatusWorkflowNameGet(
      name: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseRegistryItem>
    > {
      const localVarAxiosArgs = await StatusApiAxiosParamCreator(
        configuration
      ).apiV1StatusWorkflowNameGet(name, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This route creates a new workflow status for xene to operate on, if the workflow already exists
     * @summary Creates a new workflow status in the store.
     * @param {string} workflow WorkflowStatus manifest to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1StatusWorkflowPost(
      workflow: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ResponseHTTPMessage>
    > {
      const localVarAxiosArgs = await StatusApiAxiosParamCreator(
        configuration
      ).apiV1StatusWorkflowPost(workflow, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Returns the specified workflowStatus object from the store.
     * @param {string} [prefix] Prefix based get for workflow status documents.
     * @param {string} [name] name of the workflow to get status object for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1StatusWorkflowGet(
      prefix?: string,
      name?: string,
      options?: any
    ): AxiosPromise<ResponseRegistryItem> {
      return StatusApiFp(configuration)
        .apiV1StatusWorkflowGet(prefix, name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes the workflow status specified by the name parameter, if the workflow is not
     * @summary Deletes the specified workflow from the store.
     * @param {string} name Name of the workflow status to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1StatusWorkflowNameDelete(
      name: string,
      options?: any
    ): AxiosPromise<ResponseHTTPMessage> {
      return StatusApiFp(configuration)
        .apiV1StatusWorkflowNameDelete(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns the specified workflow object from the store with the name in params.
     * @param {string} name name of the workflow to get status document for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1StatusWorkflowNameGet(
      name: string,
      options?: any
    ): AxiosPromise<ResponseRegistryItem> {
      return StatusApiFp(configuration)
        .apiV1StatusWorkflowNameGet(name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This route creates a new workflow status for xene to operate on, if the workflow already exists
     * @summary Creates a new workflow status in the store.
     * @param {string} workflow WorkflowStatus manifest to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1StatusWorkflowPost(
      workflow: string,
      options?: any
    ): AxiosPromise<ResponseHTTPMessage> {
      return StatusApiFp(configuration)
        .apiV1StatusWorkflowPost(workflow, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
  /**
   *
   * @summary Returns the specified workflowStatus object from the store.
   * @param {string} [prefix] Prefix based get for workflow status documents.
   * @param {string} [name] name of the workflow to get status object for.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusApi
   */
  public apiV1StatusWorkflowGet(prefix?: string, name?: string, options?: any) {
    return StatusApiFp(this.configuration)
      .apiV1StatusWorkflowGet(prefix, name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes the workflow status specified by the name parameter, if the workflow is not
   * @summary Deletes the specified workflow from the store.
   * @param {string} name Name of the workflow status to be deleted.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusApi
   */
  public apiV1StatusWorkflowNameDelete(name: string, options?: any) {
    return StatusApiFp(this.configuration)
      .apiV1StatusWorkflowNameDelete(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns the specified workflow object from the store with the name in params.
   * @param {string} name name of the workflow to get status document for.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusApi
   */
  public apiV1StatusWorkflowNameGet(name: string, options?: any) {
    return StatusApiFp(this.configuration)
      .apiV1StatusWorkflowNameGet(name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This route creates a new workflow status for xene to operate on, if the workflow already exists
   * @summary Creates a new workflow status in the store.
   * @param {string} workflow WorkflowStatus manifest to be created.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusApi
   */
  public apiV1StatusWorkflowPost(workflow: string, options?: any) {
    return StatusApiFp(this.configuration)
      .apiV1StatusWorkflowPost(workflow, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
